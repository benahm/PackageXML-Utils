
/*
* Generate a package.xml file from the content.txt file
* content.txt contains the list of files with suffix 
*/

File contentFile = new File(contentFilePath);
File metadataMapFile = new File(metadataMapFilePath);

def content = contentFile.getText();
def metadataMap = new groovy.json.JsonSlurper().parseText(metadataMapFile.text); 



def getMetadataTypeByFileSuffix(metadataMap,fileSuffix){
    return metadataMap.find({ it.fileSuffix == fileSuffix});
}

def getMetadataTypeByDirectoryName(metadataMap,directoryName){
    return metadataMap.find({ it.directoryName == directoryName});
}

def getMetadataTypeByName(metadataMap,name){
    return metadataMap.find({ it.name == name});
}

// Parse 
def parseFileContent(metadataMap,content) {
    def result = [:];

    // loop through the file content
    content.eachLine { fileName, count ->

        if(!fileName.contains('.')) throw new ParseException("Error parsing the file at line ${count+1} : $fileName must have a suffix");

        def fileSuffix = fileName.substring(fileName.lastIndexOf(".")+1)
        def name = fileName.substring(0,fileName.lastIndexOf("."))

        def metadataType = getMetadataTypeByFileSuffix(metadataMap,fileSuffix)
        if(metadataType != null){
            if(metadataMap.inFolder == true){ // with folder
                if(!name.contains('/'))
                    throw new ParseException("Error parsing the file at line ${count+1} : $fileName must have a folder");
            }

            if(result[metadataType] == null) result[metadataType] = []
            result[metadataType].add(name)
        }else throw new ParseException("Error parsing the file at line ${count+1} : $fileName is invalid");

    }
    return result;
}


def copyFilesToTmp(map){
    Set metadataTypes = map.keySet();
    def absoluteTargetPackagePath = new File(targetPackagePath).absolutePath
    def absoluteSourcePackagePath = new File(sourcePackagePath).absolutePath
    metadataTypes.each({ metadataType ->
        new File("$absoluteTargetPackagePath/${metadataType.directoryName}").mkdir()  
        map[metadataType].each { name ->
            copy {
                if(metadataMap.inFolder == true)
                    into "$absoluteTargetPackagePath/${metadataType.directoryName}/"+name.substring(0,name.lastIndexOf("/"))
                else 
                    into "$absoluteTargetPackagePath/${metadataType.directoryName}"
                
                from "$absoluteSourcePackagePath/${metadataType.directoryName}/$name.${metadataType.fileSuffix}"
                from "$absoluteSourcePackagePath/${metadataType.directoryName}/$name.${metadataType.fileSuffix}-meta.xml"
            }
        }
    })
}

// Generate
def generatePackageXML(map){

    Set folders = map.keySet()
    def sw = new StringWriter()
    def xml = new groovy.xml.MarkupBuilder(sw)
    xml.mkp.xmlDeclaration(version: "1.0", encoding: "UTF-8")

    xml.Package(xmlns:"http://soap.sforce.com/2006/04/metadata"){
        folders.each({ metadataType ->
            types(){
                map[metadataType].toSet().toSorted().each { name ->
                    members(name)
                }
                name(metadataType.name)
            }
        })
        __version__(apiVersion)
    }

    File file = new File("$targetPackagePath/package.xml")

    def packageXMLContent = sw.toString().replace('__version__','version');

    file.write packageXMLContent

    return packageXMLContent
}


class ParseException extends Exception {
    ParseException(String message) {
        super(message)
    }
}


task generate {
    doLast {
        def mapResult = parseFileContent(metadataMap,content)
        copyFilesToTmp(mapResult)
        def packgeXML = generatePackageXML(mapResult)
        println "Package xml generated : \n $packgeXML"
    }
}


defaultTasks 'generate'
