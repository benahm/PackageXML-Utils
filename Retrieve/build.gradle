
/*
* Generate a package.xml file from the content.txt file
* content.txt contains the list of files with suffix 
*/

File contentFile = new File(contentFilePath);
File metadataMapFile = new File(metadataMapFilePath);

def content = contentFile.getText();
def metadataMap = new groovy.json.JsonSlurper().parseText(metadataMapFile.text); 


def getMetadataTypeByFileSuffix(metadataMap,fileSuffix){
    return metadataMap.find({ it.fileSuffix == fileSuffix});
}

def getMetadataTypeByDirectoryName(metadataMap,directoryName){
    return metadataMap.find({ it.directoryName == directoryName});
}

def getMetadataTypeByName(metadataMap,name){
    return metadataMap.find({ it.name == name});
}

// Parse 
def parseFileContent(metadataMap,content) {
    def result = [:];

    // loop through the file content
    content.eachLine { fileName, count ->

        if(!fileName.contains('.')) throw new ParseException("Error parsing the file at line ${count+1} : $fileName must have a suffix");

        def fileSuffix = fileName.substring(fileName.indexOf(".")+1)
        def fileNameWithoutSuffix = fileName.substring(0,fileName.indexOf("."))

        def metadataType = getMetadataTypeByFileSuffix(metadataMap,fileSuffix)
        if(metadataType != null){
            if(metadataMap.inFolder == true){ // with folder
                if(!fileName.contains('/'))
                    throw new ParseException("Error parsing the file at line ${count+1} : $fileName must have a folder");
            }
            if(metadataType.children != null){ // meta with children
                metadataType.children.each { childName ->
                    if(result[childName] == null) result[childName]=["*"];
                    else result[childName].add("*");
                }
            }

            if(result[metadataType.name] == null) result[metadataType.name] = []
            result[metadataType.name].add(fileNameWithoutSuffix)
        }else throw new ParseException("Error parsing the file at line ${count+1} : $fileName is invalid");

    }
    return result;
}


// Generate
def generatePackageXML(map){

    Set folders = map.keySet()
    def sw = new StringWriter()
    def xml = new groovy.xml.MarkupBuilder(sw)
    xml.mkp.xmlDeclaration(version: "1.0", encoding: "UTF-8")

    xml.Package(xmlns:"http://soap.sforce.com/2006/04/metadata"){
        folders.each({ metadataType ->
            types(){
                map[metadataType].toSet().toSorted().findAll({ fileName ->
                    return !fileName.endsWith('-meta.xml')    
                }).each { fileName ->
                    members(fileName)
                }
                name(metadataType)
            }
        })
        __version__('40.0')
    }

    File file = new File(packageXMLFilePath)

    def packageXMLContent = sw.toString().replace('__version__','version');

    file.write packageXMLContent

    return packageXMLContent
}


class ParseException extends Exception {
    ParseException(String message) {
        super(message)
    }
}


task generate {
    doLast {
        def mapResult = parseFileContent(metadataMap,content);
        def packgeXML = generatePackageXML(mapResult)
        println "Package xml generated : \n $packgeXML"
    }
}


defaultTasks 'generate'